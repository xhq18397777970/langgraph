supervisor只关注当前状态应该调度哪个agent，只关注有哪些agent，不关注工具有哪些。
且工作模式是“走一步看一步”，而不是从一开始就确定好解决问题的完整方案（调度顺序），智能调度（灵活性更强）。
supervisor通过转换控制权的方式推进流程。
依靠langraph内置持久化，实现长任务中断/恢复（如：多轮对话用户追问，补充问题、需求、关键信息）
HITL机制实现关键节点人工干预（如：interrupter_befor=["tools"]，执行这些工具前处罚中断）





11月27日：

一、npx(stdio)与sse两种mcp服务部署的方式有什么区别？
    1、因此我理解npx的方式，本质上就是将工具打包为npm包，并上传到npm的仓库中，每次需要调用时，会从仓库中下载到本地，并启用一个进程来执行，最终返回结果，相当于我把脚本下载到本地，在本地执行，一般都是stdio的通信方式。 而sse的方式，一般会将该函数部署在某个服务器上，并对外暴露一个url，当调用该工具时，实际上就是向云端的服务器发送了一个请求，并返回了结果，不需要在本地执行。

    2、npx(stdio)和sse两种部署模式：
    （1）npx：通过npm仓库将源码分发给用户，用户下载到本地并执行，通信方式几乎是stdio，因为npx启动的子进程和父进程之间最直接自然的通信通道就是stdio
    （2）sse：执行计算都在服务器上完成，通过标准http/sse请求通信

    无论是mcp服务器在本地（npx）还是云端（sse），客户端（langgraph应用）都需要扮演客户端的角色，去主动连接服务器。选择权在我：（1）工具用本地的（stdio_client连接npx启动的进程）（2）使用云端（sse_client连接暴露的url）

二、当前存在问题，mcp服务嵌入langgraph中，通过sse方式连接，但目前mcp客户端写在每个node中，当node执行任务时，每次都会执行 MCP客户端创建、MCP服务器握手建连、异步工具转换、工具调用、客户端实例删除销毁，非常浪费时间。
    1、因此mcp服务端连接的优化
        按需连接：只有实际需要时才建立MCP连接
        全局复用：避免重复连接的开销
        错误隔离：MCP服务不可用时不影响模块加载

三、发起接口调用，是同步操作，直到服务器返回响应，拿到resonse对象
    1、langgraph执行是同步执行，agent.invoke是同步调用，会阻塞直到该node工作流完成
    2、mcp客户端设计：为了提高性能，mcp客户端库被设计为异步，都是async函数（协程）

    当前，每次调用domain_node都需要创建客户端实力了，发起sse连接，进行握手并获取工具列表，进行工具转换，创建agent执行任务，函数结束客户端实例和连接被销毁